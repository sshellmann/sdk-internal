//! Mobile specific crypto operations
//!
//! This module contains temporary code for handling mobile specific cryptographic operations until
//! the SDK is fully implemented. When porting functionality from `client` the mobile clients should
//! be updated to consume the regular code paths and in this module should eventually disappear.

use std::collections::HashMap;

use base64::{engine::general_purpose::STANDARD, Engine};
use bitwarden_crypto::{
    dangerous_get_v2_rotated_account_keys, AsymmetricCryptoKey, CoseSerializable, CryptoError,
    EncString, Kdf, KeyDecryptable, KeyEncryptable, MasterKey, Pkcs8PrivateKeyBytes,
    SignatureAlgorithm, SignedPublicKey, SigningKey, SpkiPublicKeyBytes, SymmetricCryptoKey,
    UnsignedSharedKey, UserKey,
};
use bitwarden_error::bitwarden_error;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
#[cfg(feature = "wasm")]
use {tsify::Tsify, wasm_bindgen::prelude::*};

use crate::{
    client::{encryption_settings::EncryptionSettingsError, LoginMethod, UserLoginMethod},
    error::StatefulCryptoError,
    key_management::{
        AsymmetricKeyId, SecurityState, SignedSecurityState, SigningKeyId, SymmetricKeyId,
    },
    Client, NotAuthenticatedError, VaultLockedError, WrongPasswordError,
};

/// Catch all error for mobile crypto operations.
#[allow(missing_docs)]
#[bitwarden_error(flat)]
#[derive(Debug, thiserror::Error)]
pub enum CryptoClientError {
    #[error(transparent)]
    NotAuthenticated(#[from] NotAuthenticatedError),
    #[error(transparent)]
    VaultLocked(#[from] VaultLockedError),
    #[error(transparent)]
    Crypto(#[from] bitwarden_crypto::CryptoError),
}

/// State used for initializing the user cryptographic state.
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct InitUserCryptoRequest {
    /// The user's ID.
    pub user_id: Option<uuid::Uuid>,
    /// The user's KDF parameters, as received from the prelogin request
    pub kdf_params: Kdf,
    /// The user's email address
    pub email: String,
    /// The user's encrypted private key
    pub private_key: EncString,
    /// The user's signing key
    pub signing_key: Option<EncString>,
    /// The user's security state
    pub security_state: Option<SignedSecurityState>,
    /// The initialization method to use
    pub method: InitUserCryptoMethod,
}

/// The crypto method used to initialize the user cryptographic state.
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Enum))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub enum InitUserCryptoMethod {
    /// Password
    Password {
        /// The user's master password
        password: String,
        /// The user's encrypted symmetric crypto key
        user_key: EncString,
    },
    /// Never lock and/or biometric unlock
    DecryptedKey {
        /// The user's decrypted encryption key, obtained using `get_user_encryption_key`
        decrypted_user_key: String,
    },
    /// PIN
    Pin {
        /// The user's PIN
        pin: String,
        /// The user's symmetric crypto key, encrypted with the PIN. Use `derive_pin_key` to obtain
        /// this.
        pin_protected_user_key: EncString,
    },
    /// Auth request
    AuthRequest {
        /// Private Key generated by the `crate::auth::new_auth_request`.
        request_private_key: String,
        /// The type of auth request
        method: AuthRequestMethod,
    },
    /// Device Key
    DeviceKey {
        /// The device's DeviceKey
        device_key: String,
        /// The Device Private Key
        protected_device_private_key: EncString,
        /// The user's symmetric crypto key, encrypted with the Device Key.
        device_protected_user_key: UnsignedSharedKey,
    },
    /// Key connector
    KeyConnector {
        /// Base64 encoded master key, retrieved from the key connector.
        master_key: String,
        /// The user's encrypted symmetric crypto key
        user_key: EncString,
    },
}

/// Auth requests supports multiple initialization methods.
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Enum))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub enum AuthRequestMethod {
    /// User Key
    UserKey {
        /// User Key protected by the private key provided in `AuthRequestResponse`.
        protected_user_key: UnsignedSharedKey,
    },
    /// Master Key
    MasterKey {
        /// Master Key protected by the private key provided in `AuthRequestResponse`.
        protected_master_key: UnsignedSharedKey,
        /// User Key protected by the MasterKey, provided by the auth response.
        auth_request_key: EncString,
    },
}

/// Initialize the user's cryptographic state.
pub(super) async fn initialize_user_crypto(
    client: &Client,
    req: InitUserCryptoRequest,
) -> Result<(), EncryptionSettingsError> {
    use bitwarden_crypto::{DeviceKey, PinKey};

    use crate::auth::{auth_request_decrypt_master_key, auth_request_decrypt_user_key};

    if let Some(user_id) = req.user_id {
        client.internal.init_user_id(user_id)?;
    }

    let key_state = (&req).into();

    match req.method {
        InitUserCryptoMethod::Password { password, user_key } => {
            let master_key = MasterKey::derive(&password, &req.email, &req.kdf_params)?;
            client
                .internal
                .initialize_user_crypto_master_key(master_key, user_key, key_state)?;
        }
        InitUserCryptoMethod::DecryptedKey { decrypted_user_key } => {
            let user_key = SymmetricCryptoKey::try_from(decrypted_user_key)?;
            client
                .internal
                .initialize_user_crypto_decrypted_key(user_key, key_state)?;
        }
        InitUserCryptoMethod::Pin {
            pin,
            pin_protected_user_key,
        } => {
            let pin_key = PinKey::derive(pin.as_bytes(), req.email.as_bytes(), &req.kdf_params)?;
            client.internal.initialize_user_crypto_pin(
                pin_key,
                pin_protected_user_key,
                key_state,
            )?;
        }
        InitUserCryptoMethod::AuthRequest {
            request_private_key,
            method,
        } => {
            let user_key = match method {
                AuthRequestMethod::UserKey { protected_user_key } => {
                    auth_request_decrypt_user_key(request_private_key, protected_user_key)?
                }
                AuthRequestMethod::MasterKey {
                    protected_master_key,
                    auth_request_key,
                } => auth_request_decrypt_master_key(
                    request_private_key,
                    protected_master_key,
                    auth_request_key,
                )?,
            };
            client
                .internal
                .initialize_user_crypto_decrypted_key(user_key, key_state)?;
        }
        InitUserCryptoMethod::DeviceKey {
            device_key,
            protected_device_private_key,
            device_protected_user_key,
        } => {
            let device_key = DeviceKey::try_from(device_key)?;
            let user_key = device_key
                .decrypt_user_key(protected_device_private_key, device_protected_user_key)?;

            client
                .internal
                .initialize_user_crypto_decrypted_key(user_key, key_state)?;
        }
        InitUserCryptoMethod::KeyConnector {
            master_key,
            user_key,
        } => {
            let mut master_key_bytes = STANDARD
                .decode(master_key)
                .map_err(|_| CryptoError::InvalidKey)?;
            let master_key = MasterKey::try_from(master_key_bytes.as_mut_slice())?;

            client
                .internal
                .initialize_user_crypto_master_key(master_key, user_key, key_state)?;
        }
    }

    client
        .internal
        .set_login_method(crate::client::LoginMethod::User(
            crate::client::UserLoginMethod::Username {
                client_id: "".to_string(),
                email: req.email,
                kdf: req.kdf_params,
            },
        ));

    Ok(())
}

/// Represents the request to initialize the user's organizational cryptographic state.
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct InitOrgCryptoRequest {
    /// The encryption keys for all the organizations the user is a part of
    pub organization_keys: HashMap<uuid::Uuid, UnsignedSharedKey>,
}

/// Initialize the user's organizational cryptographic state.
pub(super) async fn initialize_org_crypto(
    client: &Client,
    req: InitOrgCryptoRequest,
) -> Result<(), EncryptionSettingsError> {
    let organization_keys = req.organization_keys.into_iter().collect();
    client.internal.initialize_org_crypto(organization_keys)?;
    Ok(())
}

pub(super) async fn get_user_encryption_key(client: &Client) -> Result<String, CryptoClientError> {
    let key_store = client.internal.get_key_store();
    let ctx = key_store.context();
    // This is needed because the mobile clients need access to the user encryption key
    #[allow(deprecated)]
    let user_key = ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)?;

    Ok(user_key.to_base64())
}

/// Response from the `update_password` function
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct UpdatePasswordResponse {
    /// Hash of the new password
    password_hash: String,
    /// User key, encrypted with the new password
    new_key: EncString,
}

pub(super) fn update_password(
    client: &Client,
    new_password: String,
) -> Result<UpdatePasswordResponse, CryptoClientError> {
    let key_store = client.internal.get_key_store();
    let ctx = key_store.context();
    // FIXME: [PM-18099] Once MasterKey deals with KeyIds, this should be updated
    #[allow(deprecated)]
    let user_key = ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)?;

    let login_method = client
        .internal
        .get_login_method()
        .ok_or(NotAuthenticatedError)?;

    // Derive a new master key from password
    let new_master_key = match login_method.as_ref() {
        LoginMethod::User(
            UserLoginMethod::Username { email, kdf, .. }
            | UserLoginMethod::ApiKey { email, kdf, .. },
        ) => MasterKey::derive(&new_password, email, kdf)?,
        #[cfg(feature = "secrets")]
        LoginMethod::ServiceAccount(_) => return Err(NotAuthenticatedError)?,
    };

    let new_key = new_master_key.encrypt_user_key(user_key)?;

    let password_hash = new_master_key.derive_master_key_hash(
        new_password.as_bytes(),
        bitwarden_crypto::HashPurpose::ServerAuthorization,
    )?;

    Ok(UpdatePasswordResponse {
        password_hash,
        new_key,
    })
}

/// Request for deriving a pin protected user key
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct DerivePinKeyResponse {
    /// [UserKey] protected by PIN
    pin_protected_user_key: EncString,
    /// PIN protected by [UserKey]
    encrypted_pin: EncString,
}

pub(super) fn derive_pin_key(
    client: &Client,
    pin: String,
) -> Result<DerivePinKeyResponse, CryptoClientError> {
    let key_store = client.internal.get_key_store();
    let ctx = key_store.context();
    // FIXME: [PM-18099] Once PinKey deals with KeyIds, this should be updated
    #[allow(deprecated)]
    let user_key = ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)?;

    let login_method = client
        .internal
        .get_login_method()
        .ok_or(NotAuthenticatedError)?;

    let pin_protected_user_key = derive_pin_protected_user_key(&pin, &login_method, user_key)?;

    Ok(DerivePinKeyResponse {
        pin_protected_user_key,
        encrypted_pin: pin.encrypt_with_key(user_key)?,
    })
}

pub(super) fn derive_pin_user_key(
    client: &Client,
    encrypted_pin: EncString,
) -> Result<EncString, CryptoClientError> {
    let key_store = client.internal.get_key_store();
    let ctx = key_store.context();
    // FIXME: [PM-18099] Once PinKey deals with KeyIds, this should be updated
    #[allow(deprecated)]
    let user_key = ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)?;

    let pin: String = encrypted_pin.decrypt_with_key(user_key)?;
    let login_method = client
        .internal
        .get_login_method()
        .ok_or(NotAuthenticatedError)?;

    derive_pin_protected_user_key(&pin, &login_method, user_key)
}

fn derive_pin_protected_user_key(
    pin: &str,
    login_method: &LoginMethod,
    user_key: &SymmetricCryptoKey,
) -> Result<EncString, CryptoClientError> {
    use bitwarden_crypto::PinKey;

    let derived_key = match login_method {
        LoginMethod::User(
            UserLoginMethod::Username { email, kdf, .. }
            | UserLoginMethod::ApiKey { email, kdf, .. },
        ) => PinKey::derive(pin.as_bytes(), email.as_bytes(), kdf)?,
        #[cfg(feature = "secrets")]
        LoginMethod::ServiceAccount(_) => return Err(NotAuthenticatedError)?,
    };

    Ok(derived_key.encrypt_user_key(user_key)?)
}

#[allow(missing_docs)]
#[bitwarden_error(flat)]
#[derive(Debug, thiserror::Error)]
pub enum EnrollAdminPasswordResetError {
    #[error(transparent)]
    VaultLocked(#[from] VaultLockedError),
    #[error(transparent)]
    Crypto(#[from] bitwarden_crypto::CryptoError),
    #[error(transparent)]
    InvalidBase64(#[from] base64::DecodeError),
}

pub(super) fn enroll_admin_password_reset(
    client: &Client,
    public_key: String,
) -> Result<UnsignedSharedKey, EnrollAdminPasswordResetError> {
    use base64::{engine::general_purpose::STANDARD, Engine};
    use bitwarden_crypto::AsymmetricPublicCryptoKey;

    let public_key = AsymmetricPublicCryptoKey::from_der(&SpkiPublicKeyBytes::from(
        STANDARD.decode(public_key)?,
    ))?;
    let key_store = client.internal.get_key_store();
    let ctx = key_store.context();
    // FIXME: [PM-18110] This should be removed once the key store can handle public key encryption
    #[allow(deprecated)]
    let key = ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)?;

    Ok(UnsignedSharedKey::encapsulate_key_unsigned(
        key,
        &public_key,
    )?)
}

/// Request for migrating an account from password to key connector.
#[derive(Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct DeriveKeyConnectorRequest {
    /// Encrypted user key, used to validate the master key
    pub user_key_encrypted: EncString,
    /// The user's master password
    pub password: String,
    /// The KDF parameters used to derive the master key
    pub kdf: Kdf,
    /// The user's email address
    pub email: String,
}

#[allow(missing_docs)]
#[bitwarden_error(flat)]
#[derive(Debug, thiserror::Error)]
pub enum DeriveKeyConnectorError {
    #[error(transparent)]
    WrongPassword(#[from] WrongPasswordError),
    #[error(transparent)]
    Crypto(#[from] bitwarden_crypto::CryptoError),
}

/// Derive the master key for migrating to the key connector
pub(super) fn derive_key_connector(
    request: DeriveKeyConnectorRequest,
) -> Result<String, DeriveKeyConnectorError> {
    let master_key = MasterKey::derive(&request.password, &request.email, &request.kdf)?;
    master_key
        .decrypt_user_key(request.user_key_encrypted)
        .map_err(|_| WrongPasswordError)?;

    Ok(master_key.to_base64())
}

/// Response from the `make_key_pair` function
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct MakeKeyPairResponse {
    /// The user's public key
    user_public_key: String,
    /// User's private key, encrypted with the user key
    user_key_encrypted_private_key: EncString,
}

pub(super) fn make_key_pair(user_key: String) -> Result<MakeKeyPairResponse, CryptoError> {
    let user_key = UserKey::new(SymmetricCryptoKey::try_from(user_key)?);

    let key_pair = user_key.make_key_pair()?;

    Ok(MakeKeyPairResponse {
        user_public_key: key_pair.public,
        user_key_encrypted_private_key: key_pair.private,
    })
}

/// Request for `verify_asymmetric_keys`.
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct VerifyAsymmetricKeysRequest {
    /// The user's user key
    user_key: String,
    /// The user's public key
    user_public_key: String,
    /// User's private key, encrypted with the user key
    user_key_encrypted_private_key: EncString,
}

/// Response for `verify_asymmetric_keys`.
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct VerifyAsymmetricKeysResponse {
    /// Whether the user's private key was decryptable by the user key.
    private_key_decryptable: bool,
    /// Whether the user's private key was a valid RSA key and matched the public key provided.
    valid_private_key: bool,
}

pub(super) fn verify_asymmetric_keys(
    request: VerifyAsymmetricKeysRequest,
) -> Result<VerifyAsymmetricKeysResponse, CryptoError> {
    #[derive(Debug, thiserror::Error)]
    enum VerifyError {
        #[error("Failed to decrypt private key: {0:?}")]
        DecryptFailed(bitwarden_crypto::CryptoError),
        #[error("Failed to parse decrypted private key: {0:?}")]
        ParseFailed(bitwarden_crypto::CryptoError),
        #[error("Failed to derive a public key: {0:?}")]
        PublicFailed(bitwarden_crypto::CryptoError),
        #[error("Derived public key doesn't match")]
        KeyMismatch,
    }

    fn verify_inner(
        user_key: &SymmetricCryptoKey,
        request: &VerifyAsymmetricKeysRequest,
    ) -> Result<(), VerifyError> {
        let decrypted_private_key: Vec<u8> = request
            .user_key_encrypted_private_key
            .decrypt_with_key(user_key)
            .map_err(VerifyError::DecryptFailed)?;

        let decrypted_private_key = Pkcs8PrivateKeyBytes::from(decrypted_private_key);
        let private_key = AsymmetricCryptoKey::from_der(&decrypted_private_key)
            .map_err(VerifyError::ParseFailed)?;

        let derived_public_key_vec = private_key
            .to_public_key()
            .to_der()
            .map_err(VerifyError::PublicFailed)?;

        let derived_public_key = STANDARD.encode(derived_public_key_vec);

        if derived_public_key != request.user_public_key {
            return Err(VerifyError::KeyMismatch);
        }
        Ok(())
    }

    let user_key = SymmetricCryptoKey::try_from(request.user_key.clone())?;

    Ok(match verify_inner(&user_key, &request) {
        Ok(_) => VerifyAsymmetricKeysResponse {
            private_key_decryptable: true,
            valid_private_key: true,
        },
        Err(e) => {
            log::debug!("User asymmetric keys verification: {e}");

            VerifyAsymmetricKeysResponse {
                private_key_decryptable: !matches!(e, VerifyError::DecryptFailed(_)),
                valid_private_key: false,
            }
        }
    })
}

/// Response for the `make_keys_for_user_crypto_v2`, containing a set of keys for a user
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "uniffi", derive(uniffi::Record))]
#[cfg_attr(feature = "wasm", derive(Tsify), tsify(into_wasm_abi, from_wasm_abi))]
pub struct UserCryptoV2KeysResponse {
    /// User key
    user_key: String,

    /// Wrapped private key
    private_key: EncString,
    /// Public key
    public_key: String,
    /// The user's public key, signed by the signing key
    signed_public_key: SignedPublicKey,

    /// Signing key, encrypted with the user's symmetric key
    signing_key: EncString,
    /// Base64 encoded verifying key
    verifying_key: String,

    /// The user's signed security state
    security_state: SignedSecurityState,
    /// The security state's version
    security_version: u64,
}

/// Creates the user's cryptographic state for v2 users. This includes ensuring signature key pair
/// is present, a signed public key is present, a security state is present and signed, and the user
/// key is a Cose key.
pub(crate) fn make_v2_keys_for_v1_user(
    client: &Client,
) -> Result<UserCryptoV2KeysResponse, StatefulCryptoError> {
    let key_store = client.internal.get_key_store();
    let mut ctx = key_store.context();

    let temporary_user_key_id = SymmetricKeyId::Local("temporary_user_key");
    let temporary_signing_key_id = SigningKeyId::Local("temporary_signing_key");
    // Re-use existing private key
    let private_key_id = AsymmetricKeyId::UserPrivateKey;

    // Ensure that the function is only called for a V1 user.
    if client.internal.get_security_version() != 1 {
        return Err(StatefulCryptoError::WrongAccountCryptoVersion {
            expected: "1".to_string(),
            got: 2,
        });
    }

    // Ensure the user has a private key.
    // V1 user must have a private key to upgrade. This should be ensured by the client before
    // calling the upgrade function.
    if !ctx.has_asymmetric_key(AsymmetricKeyId::UserPrivateKey) {
        return Err(StatefulCryptoError::CryptoError(CryptoError::MissingKeyId(
            "UserPrivateKey".to_string(),
        )));
    }

    #[allow(deprecated)]
    let private_key = ctx.dangerous_get_asymmetric_key(private_key_id)?.clone();

    // New user key
    let user_key = SymmetricCryptoKey::make_xchacha20_poly1305_key();
    #[allow(deprecated)]
    ctx.set_symmetric_key(temporary_user_key_id, user_key.clone())?;

    // New signing key
    let signing_key = SigningKey::make(SignatureAlgorithm::Ed25519);
    #[allow(deprecated)]
    ctx.set_signing_key(temporary_signing_key_id, signing_key.clone())?;

    // Sign existing public key
    let signed_public_key = ctx.make_signed_public_key(private_key_id, temporary_signing_key_id)?;
    let public_key = private_key.to_public_key();

    // Initialize security state for the user
    let security_state = SecurityState::initialize_for_user(
        client
            .internal
            .get_user_id()
            .ok_or(StatefulCryptoError::MissingSecurityState)?,
    );
    let signed_security_state = security_state.sign(temporary_signing_key_id, &mut ctx)?;

    Ok(UserCryptoV2KeysResponse {
        user_key: user_key.to_base64(),

        private_key: private_key.to_der()?.encrypt_with_key(&user_key)?,
        public_key: STANDARD.encode(public_key.to_der()?),
        signed_public_key,

        signing_key: signing_key.to_cose().encrypt_with_key(&user_key)?,
        verifying_key: STANDARD.encode(signing_key.to_verifying_key().to_cose()),

        security_state: signed_security_state,
        security_version: security_state.version(),
    })
}

/// Gets a set of new wrapped account keys for a user, given a new user key.
///
/// In the current implementation, it just re-encrypts any existing keys. This function expects a
/// user to be a v2 user; that is, they have a signing key, a cose user-key, and a private key
pub(crate) fn get_v2_rotated_account_keys(
    client: &Client,
) -> Result<UserCryptoV2KeysResponse, StatefulCryptoError> {
    let key_store = client.internal.get_key_store();
    let mut ctx = key_store.context();

    // Ensure that the function is only called for a V2 user.
    // V2 users have a security version 2 or higher.
    if client.internal.get_security_version() == 1 {
        return Err(StatefulCryptoError::WrongAccountCryptoVersion {
            expected: "2+".to_string(),
            got: 1,
        });
    }

    let security_state = client
        .internal
        .security_state
        .read()
        .expect("RwLock is not poisoned")
        .to_owned()
        // This cannot occur since the security version check above already ensures that the
        // security state is present.
        .ok_or(StatefulCryptoError::MissingSecurityState)?;

    let rotated_keys = dangerous_get_v2_rotated_account_keys(
        AsymmetricKeyId::UserPrivateKey,
        SigningKeyId::UserSigningKey,
        &ctx,
    )?;

    Ok(UserCryptoV2KeysResponse {
        user_key: rotated_keys.user_key.to_base64(),

        private_key: rotated_keys.private_key,
        public_key: STANDARD.encode(rotated_keys.public_key),
        signed_public_key: rotated_keys.signed_public_key,

        signing_key: rotated_keys.signing_key,
        verifying_key: STANDARD.encode(rotated_keys.verifying_key),

        security_state: security_state.sign(SigningKeyId::UserSigningKey, &mut ctx)?,
        security_version: security_state.version(),
    })
}

#[cfg(test)]
mod tests {
    use std::num::NonZeroU32;

    use bitwarden_crypto::RsaKeyPair;

    use super::*;
    use crate::{client::internal::UserKeyState, Client};
    const TEST_VECTOR_USER_KEY_V2_B64: &str = "pQEEAlACHUUoybNAuJoZzqNMxz2bAzoAARFvBIQDBAUGIFggAvGl4ifaUAomQdCdUPpXLHtypiQxHjZwRHeI83caZM4B";
    const TEST_VECTOR_PRIVATE_KEY_V2: &str = "7.g1gdowE6AAERbwMZARwEUAIdRSjJs0C4mhnOo0zHPZuhBVgYthGLGqVLPeidY8mNMxpLJn3fyeSxyaWsWQTR6pxmRV2DyGZXly/0l9KK+Rsfetl9wvYIz0O4/RW3R6wf7eGxo5XmicV3WnFsoAmIQObxkKWShxFyjzg+ocKItQDzG7Gp6+MW4biTrAlfK51ML/ZS+PCjLmgI1QQr4eMHjiwA2TBKtKkxfjoTJkMXECpRVLEXOo8/mbIGYkuabbSA7oU+TJ0yXlfKDtD25gnyO7tjW/0JMFUaoEKRJOuKoXTN4n/ks4Hbxk0X5/DzfG05rxWad2UNBjNg7ehW99WrQ+33ckdQFKMQOri/rt8JzzrF1k11/jMJ+Y2TADKNHr91NalnUX+yqZAAe3sRt5Pv5ZhLIwRMKQi/1NrLcsQPRuUnogVSPOoMnE/eD6F70iU60Z6pvm1iBw2IvELZcrs/oxpO2SeCue08fIZW/jNZokbLnm90tQ7QeZTUpiPALhUgfGOa3J9VOJ7jQGCqDjd9CzV2DCVfhKCapeTbldm+RwEWBz5VvorH5vMx1AzbPRJxdIQuxcg3NqRrXrYC7fyZljWaPB9qP1tztiPtd1PpGEgxLByIfR6fqyZMCvOBsWbd0H6NhF8mNVdDw60+skFRdbRBTSCjCtKZeLVuVFb8ioH45PR5oXjtx4atIDzu6DKm6TTMCbR6DjZuZZ8GbwHxuUD2mDD3pAFhaof9kR3lQdjy7Zb4EzUUYskQxzcLPcqzp9ZgB3Rg91SStBCCMhdQ6AnhTy+VTGt/mY5AbBXNRSL6fI0r+P9K8CcEI4bNZCDkwwQr5v4O4ykSUzIvmVU0zKzDngy9bteIZuhkvGUoZlQ9UATNGPhoLfqq2eSvqEXkCbxTVZ5D+Ww9pHmWeVcvoBhcl5MvicfeQt++dY3tPjIfZq87nlugG4HiNbcv9nbVpgwe3v8cFetWXQgnO4uhx8JHSwGoSuxHFZtl2sdahjTHavRHnYjSABEFrViUKgb12UDD5ow1GAL62wVdSJKRf9HlLbJhN3PBxuh5L/E0wy1wGA9ecXtw/R1ktvXZ7RklGAt1TmNzZv6vI2J/CMXvndOX9rEpjKMbwbIDAjQ9PxiWdcnmc5SowT9f6yfIjbjXnRMWWidPAua7sgrtej4HP4Qjz1fpgLMLCRyF97tbMTmsAI5Cuj98Buh9PwcdyXj5SbVuHdJS1ehv9b5SWPsD4pwOm3+otVNK6FTazhoUl47AZoAoQzXfsXxrzqYzvF0yJkCnk9S1dcij1L569gQ43CJO6o6jIZFJvA4EmZDl95ELu+BC+x37Ip8dq4JLPsANDVSqvXO9tfDUIXEx25AaOYhW2KAUoDve/fbsU8d0UZR1o/w+ZrOQwawCIPeVPtbh7KFRVQi/rPI+Abl6XR6qMJbKPegliYGUuGF2oEMEc6QLTsMRCEPuw0S3kxbNfVPqml8nGhB2r8zUHBY1diJEmipVghnwH74gIKnyJ2C9nKjV8noUfKzqyV8vxUX2G5yXgodx8Jn0cWs3XhWuApFla9z4R28W/4jA1jK2WQMlx+b6xKUWgRk8+fYsc0HSt2fDrQ9pLpnjb8ME59RCxSPV++PThpnR2JtastZBZur2hBIJsGILCAmufUU4VC4gBKPhNfu/OK4Ktgz+uQlUa9fEC/FnkpTRQPxHuQjSQSNrIIyW1bIRBtnwjvvvNoui9FZJ";
    #[allow(unused)]
    const TEST_VECTOR_PUBLIC_KEY_V2: &str = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz/+1jPJ1HqcaCdKrTPms8XJcvnmd9alI42U2XF/4GMNTM5KF1gI6snhR/23ZLatZRFMHoK8ZCMSpGNkjLadArz52ldceTvBOhQUiWylkZQ4NfNa3xIYJubXOmkeDyfNuyLxVZvcZOko9PdT+Qx2QxDrFi2XNo2I7aVFd19/COIEkex4mJ0eA3MHFpKCdxYbcTAsGID8+kVR9L84S1JptZoG8x+iB/D3/Q4y02UsQYpFTu0vbPY84YmW03ngJdxWzS8X4/UJI/jaEn5rO4xlU5QcL0l4IybP5LRpE9XEeUHATKVOG7eNfpe9zDfKV2qQoofQMH9VvkWO4psaWDjBSdwIDAQAB";
    #[allow(unused)]
    const TEST_VECTOR_SIGNED_PUBLIC_KEY_V2: &str = "hFgepAEnAxg8BFAmkP0QgfdMVbIujX55W/yNOgABOH8BoFkBTqNpYWxnb3JpdGhtAG1jb250ZW50Rm9ybWF0AGlwdWJsaWNLZXlZASYwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDP/7WM8nUepxoJ0qtM+azxcly+eZ31qUjjZTZcX/gYw1MzkoXWAjqyeFH/bdktq1lEUwegrxkIxKkY2SMtp0CvPnaV1x5O8E6FBSJbKWRlDg181rfEhgm5tc6aR4PJ827IvFVm9xk6Sj091P5DHZDEOsWLZc2jYjtpUV3X38I4gSR7HiYnR4DcwcWkoJ3FhtxMCwYgPz6RVH0vzhLUmm1mgbzH6IH8Pf9DjLTZSxBikVO7S9s9jzhiZbTeeAl3FbNLxfj9Qkj+NoSfms7jGVTlBwvSXgjJs/ktGkT1cR5QcBMpU4bt41+l73MN8pXapCih9Awf1W+RY7imxpYOMFJ3AgMBAAFYQMq/hT4wod2w8xyoM7D86ctuLNX4ZRo+jRHf2sZfaO7QsvonG/ZYuNKF5fq8wpxMRjfoMvnY2TTShbgzLrW8BA4=";
    const TEST_VECTOR_SIGNING_KEY_V2: &str = "7.g1gcowE6AAERbwMYZQRQAh1FKMmzQLiaGc6jTMc9m6EFWBhYePc2qkCruHAPXgbzXsIP1WVk11ArbLNYUBpifToURlwHKs1je2BwZ1C/5thz4nyNbL0wDaYkRWI9ex1wvB7KhdzC7ltStEd5QttboTSCaXQROSZaGBPNO5+Bu3sTY8F5qK1pBUo6AHNN";
    #[allow(unused)]
    const TEST_VECTOR_VERIFYING_KEY_V2: &str =
        "pgEBAlAmkP0QgfdMVbIujX55W/yNAycEgQIgBiFYIEM6JxBmjWQTruAm3s6BTaJy1q6BzQetMBacNeRJ0kxR";
    const TEST_VECTOR_SECURITY_STATE_V2: &str = "hFgepAEnAxg8BFAmkP0QgfdMVbIujX55W/yNOgABOH8CoFgkomhlbnRpdHlJZFBHOOw2BI9OQoNq+Vl1xZZKZ3ZlcnNpb24CWEAlchbJR0vmRfShG8On7Q2gknjkw4Dd6MYBLiH4u+/CmfQdmjNZdf6kozgW/6NXyKVNu8dAsKsin+xxXkDyVZoG";

    #[tokio::test]
    async fn test_update_password() {
        let client = Client::new(None);

        let priv_key: EncString = "2.kmLY8NJVuiKBFJtNd/ZFpA==|qOodlRXER+9ogCe3yOibRHmUcSNvjSKhdDuztLlucs10jLiNoVVVAc+9KfNErLSpx5wmUF1hBOJM8zwVPjgQTrmnNf/wuDpwiaCxNYb/0v4FygPy7ccAHK94xP1lfqq7U9+tv+/yiZSwgcT+xF0wFpoxQeNdNRFzPTuD9o4134n8bzacD9DV/WjcrXfRjbBCzzuUGj1e78+A7BWN7/5IWLz87KWk8G7O/W4+8PtEzlwkru6Wd1xO19GYU18oArCWCNoegSmcGn7w7NDEXlwD403oY8Oa7ylnbqGE28PVJx+HLPNIdSC6YKXeIOMnVs7Mctd/wXC93zGxAWD6ooTCzHSPVV50zKJmWIG2cVVUS7j35H3rGDtUHLI+ASXMEux9REZB8CdVOZMzp2wYeiOpggebJy6MKOZqPT1R3X0fqF2dHtRFPXrNsVr1Qt6bS9qTyO4ag1/BCvXF3P1uJEsI812BFAne3cYHy5bIOxuozPfipJrTb5WH35bxhElqwT3y/o/6JWOGg3HLDun31YmiZ2HScAsUAcEkA4hhoTNnqy4O2s3yVbCcR7jF7NLsbQc0MDTbnjxTdI4VnqUIn8s2c9hIJy/j80pmO9Bjxp+LQ9a2hUkfHgFhgHxZUVaeGVth8zG2kkgGdrp5VHhxMVFfvB26Ka6q6qE/UcS2lONSv+4T8niVRJz57qwctj8MNOkA3PTEfe/DP/LKMefke31YfT0xogHsLhDkx+mS8FCc01HReTjKLktk/Jh9mXwC5oKwueWWwlxI935ecn+3I2kAuOfMsgPLkoEBlwgiREC1pM7VVX1x8WmzIQVQTHd4iwnX96QewYckGRfNYWz/zwvWnjWlfcg8kRSe+68EHOGeRtC5r27fWLqRc0HNcjwpgHkI/b6czerCe8+07TWql4keJxJxhBYj3iOH7r9ZS8ck51XnOb8tGL1isimAJXodYGzakwktqHAD7MZhS+P02O+6jrg7d+yPC2ZCuS/3TOplYOCHQIhnZtR87PXTUwr83zfOwAwCyv6KP84JUQ45+DItrXLap7nOVZKQ5QxYIlbThAO6eima6Zu5XHfqGPMNWv0bLf5+vAjIa5np5DJrSwz9no/hj6CUh0iyI+SJq4RGI60lKtypMvF6MR3nHLEHOycRUQbZIyTHWl4QQLdHzuwN9lv10ouTEvNr6sFflAX2yb6w3hlCo7oBytH3rJekjb3IIOzBpeTPIejxzVlh0N9OT5MZdh4sNKYHUoWJ8mnfjdM+L4j5Q2Kgk/XiGDgEebkUxiEOQUdVpePF5uSCE+TPav/9FIRGXGiFn6NJMaU7aBsDTFBLloffFLYDpd8/bTwoSvifkj7buwLYM+h/qcnfdy5FWau1cKav+Blq/ZC0qBpo658RTC8ZtseAFDgXoQZuksM10hpP9bzD04Bx30xTGX81QbaSTNwSEEVrOtIhbDrj9OI43KH4O6zLzK+t30QxAv5zjk10RZ4+5SAdYndIlld9Y62opCfPDzRy3ubdve4ZEchpIKWTQvIxq3T5ogOhGaWBVYnkMtM2GVqvWV//46gET5SH/MdcwhACUcZ9kCpMnWH9CyyUwYvTT3UlNyV+DlS27LMPvaw7tx7qa+GfNCoCBd8S4esZpQYK/WReiS8=|pc7qpD42wxyXemdNPuwxbh8iIaryrBPu8f/DGwYdHTw=".parse().unwrap();

        let kdf = Kdf::PBKDF2 {
            iterations: 100_000.try_into().unwrap(),
        };

        initialize_user_crypto(
            & client,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: kdf.clone(),
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                signing_key: None,
                security_state: None,
                method: InitUserCryptoMethod::Password {
                    password: "asdfasdfasdf".into(),
                    user_key: "2.u2HDQ/nH2J7f5tYHctZx6Q==|NnUKODz8TPycWJA5svexe1wJIz2VexvLbZh2RDfhj5VI3wP8ZkR0Vicvdv7oJRyLI1GyaZDBCf9CTBunRTYUk39DbZl42Rb+Xmzds02EQhc=|rwuo5wgqvTJf3rgwOUfabUyzqhguMYb3sGBjOYqjevc=".parse().unwrap(),
                },
            },
        )
        .await
        .unwrap();

        let new_password_response = update_password(&client, "123412341234".into()).unwrap();

        let client2 = Client::new(None);

        initialize_user_crypto(
            &client2,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: kdf.clone(),
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                signing_key: None,
                security_state: None,
                method: InitUserCryptoMethod::Password {
                    password: "123412341234".into(),
                    user_key: new_password_response.new_key,
                },
            },
        )
        .await
        .unwrap();

        let new_hash = client2
            .kdf()
            .hash_password(
                "test@bitwarden.com".into(),
                "123412341234".into(),
                kdf.clone(),
                bitwarden_crypto::HashPurpose::ServerAuthorization,
            )
            .await
            .unwrap();

        assert_eq!(new_hash, new_password_response.password_hash);

        let client_key = {
            let key_store = client.internal.get_key_store();
            let ctx = key_store.context();
            #[allow(deprecated)]
            ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)
                .unwrap()
                .to_base64()
        };

        let client2_key = {
            let key_store = client2.internal.get_key_store();
            let ctx = key_store.context();
            #[allow(deprecated)]
            ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)
                .unwrap()
                .to_base64()
        };

        assert_eq!(client_key, client2_key);
    }

    #[tokio::test]
    async fn test_initialize_user_crypto_pin() {
        let client = Client::new(None);

        let priv_key: EncString = "2.kmLY8NJVuiKBFJtNd/ZFpA==|qOodlRXER+9ogCe3yOibRHmUcSNvjSKhdDuztLlucs10jLiNoVVVAc+9KfNErLSpx5wmUF1hBOJM8zwVPjgQTrmnNf/wuDpwiaCxNYb/0v4FygPy7ccAHK94xP1lfqq7U9+tv+/yiZSwgcT+xF0wFpoxQeNdNRFzPTuD9o4134n8bzacD9DV/WjcrXfRjbBCzzuUGj1e78+A7BWN7/5IWLz87KWk8G7O/W4+8PtEzlwkru6Wd1xO19GYU18oArCWCNoegSmcGn7w7NDEXlwD403oY8Oa7ylnbqGE28PVJx+HLPNIdSC6YKXeIOMnVs7Mctd/wXC93zGxAWD6ooTCzHSPVV50zKJmWIG2cVVUS7j35H3rGDtUHLI+ASXMEux9REZB8CdVOZMzp2wYeiOpggebJy6MKOZqPT1R3X0fqF2dHtRFPXrNsVr1Qt6bS9qTyO4ag1/BCvXF3P1uJEsI812BFAne3cYHy5bIOxuozPfipJrTb5WH35bxhElqwT3y/o/6JWOGg3HLDun31YmiZ2HScAsUAcEkA4hhoTNnqy4O2s3yVbCcR7jF7NLsbQc0MDTbnjxTdI4VnqUIn8s2c9hIJy/j80pmO9Bjxp+LQ9a2hUkfHgFhgHxZUVaeGVth8zG2kkgGdrp5VHhxMVFfvB26Ka6q6qE/UcS2lONSv+4T8niVRJz57qwctj8MNOkA3PTEfe/DP/LKMefke31YfT0xogHsLhDkx+mS8FCc01HReTjKLktk/Jh9mXwC5oKwueWWwlxI935ecn+3I2kAuOfMsgPLkoEBlwgiREC1pM7VVX1x8WmzIQVQTHd4iwnX96QewYckGRfNYWz/zwvWnjWlfcg8kRSe+68EHOGeRtC5r27fWLqRc0HNcjwpgHkI/b6czerCe8+07TWql4keJxJxhBYj3iOH7r9ZS8ck51XnOb8tGL1isimAJXodYGzakwktqHAD7MZhS+P02O+6jrg7d+yPC2ZCuS/3TOplYOCHQIhnZtR87PXTUwr83zfOwAwCyv6KP84JUQ45+DItrXLap7nOVZKQ5QxYIlbThAO6eima6Zu5XHfqGPMNWv0bLf5+vAjIa5np5DJrSwz9no/hj6CUh0iyI+SJq4RGI60lKtypMvF6MR3nHLEHOycRUQbZIyTHWl4QQLdHzuwN9lv10ouTEvNr6sFflAX2yb6w3hlCo7oBytH3rJekjb3IIOzBpeTPIejxzVlh0N9OT5MZdh4sNKYHUoWJ8mnfjdM+L4j5Q2Kgk/XiGDgEebkUxiEOQUdVpePF5uSCE+TPav/9FIRGXGiFn6NJMaU7aBsDTFBLloffFLYDpd8/bTwoSvifkj7buwLYM+h/qcnfdy5FWau1cKav+Blq/ZC0qBpo658RTC8ZtseAFDgXoQZuksM10hpP9bzD04Bx30xTGX81QbaSTNwSEEVrOtIhbDrj9OI43KH4O6zLzK+t30QxAv5zjk10RZ4+5SAdYndIlld9Y62opCfPDzRy3ubdve4ZEchpIKWTQvIxq3T5ogOhGaWBVYnkMtM2GVqvWV//46gET5SH/MdcwhACUcZ9kCpMnWH9CyyUwYvTT3UlNyV+DlS27LMPvaw7tx7qa+GfNCoCBd8S4esZpQYK/WReiS8=|pc7qpD42wxyXemdNPuwxbh8iIaryrBPu8f/DGwYdHTw=".parse().unwrap();

        initialize_user_crypto(
            & client,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                signing_key: None,
                security_state: None,
                method: InitUserCryptoMethod::Password {
                    password: "asdfasdfasdf".into(),
                    user_key: "2.u2HDQ/nH2J7f5tYHctZx6Q==|NnUKODz8TPycWJA5svexe1wJIz2VexvLbZh2RDfhj5VI3wP8ZkR0Vicvdv7oJRyLI1GyaZDBCf9CTBunRTYUk39DbZl42Rb+Xmzds02EQhc=|rwuo5wgqvTJf3rgwOUfabUyzqhguMYb3sGBjOYqjevc=".parse().unwrap(),
                },
            },
        )
        .await
        .unwrap();

        let pin_key = derive_pin_key(&client, "1234".into()).unwrap();

        // Verify we can unlock with the pin
        let client2 = Client::new(None);
        initialize_user_crypto(
            &client2,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                signing_key: None,
                security_state: None,
                method: InitUserCryptoMethod::Pin {
                    pin: "1234".into(),
                    pin_protected_user_key: pin_key.pin_protected_user_key,
                },
            },
        )
        .await
        .unwrap();

        let client_key = {
            let key_store = client.internal.get_key_store();
            let ctx = key_store.context();
            #[allow(deprecated)]
            ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)
                .unwrap()
                .to_base64()
        };

        let client2_key = {
            let key_store = client2.internal.get_key_store();
            let ctx = key_store.context();
            #[allow(deprecated)]
            ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)
                .unwrap()
                .to_base64()
        };

        assert_eq!(client_key, client2_key);

        // Verify we can derive the pin protected user key from the encrypted pin
        let pin_protected_user_key = derive_pin_user_key(&client, pin_key.encrypted_pin).unwrap();

        let client3 = Client::new(None);

        initialize_user_crypto(
            &client3,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                signing_key: None,
                security_state: None,
                method: InitUserCryptoMethod::Pin {
                    pin: "1234".into(),
                    pin_protected_user_key,
                },
            },
        )
        .await
        .unwrap();

        let client_key = {
            let key_store = client.internal.get_key_store();
            let ctx = key_store.context();
            #[allow(deprecated)]
            ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)
                .unwrap()
                .to_base64()
        };

        let client3_key = {
            let key_store = client3.internal.get_key_store();
            let ctx = key_store.context();
            #[allow(deprecated)]
            ctx.dangerous_get_symmetric_key(SymmetricKeyId::User)
                .unwrap()
                .to_base64()
        };

        assert_eq!(client_key, client3_key);
    }

    #[test]
    fn test_enroll_admin_password_reset() {
        let client = Client::new(None);

        let master_key = MasterKey::derive(
            "asdfasdfasdf",
            "test@bitwarden.com",
            &Kdf::PBKDF2 {
                iterations: NonZeroU32::new(600_000).unwrap(),
            },
        )
        .unwrap();

        let user_key = "2.Q/2PhzcC7GdeiMHhWguYAQ==|GpqzVdr0go0ug5cZh1n+uixeBC3oC90CIe0hd/HWA/pTRDZ8ane4fmsEIcuc8eMKUt55Y2q/fbNzsYu41YTZzzsJUSeqVjT8/iTQtgnNdpo=|dwI+uyvZ1h/iZ03VQ+/wrGEFYVewBUUl/syYgjsNMbE=".parse().unwrap();
        let private_key ="2.yN7l00BOlUE0Sb0M//Q53w==|EwKG/BduQRQ33Izqc/ogoBROIoI5dmgrxSo82sgzgAMIBt3A2FZ9vPRMY+GWT85JiqytDitGR3TqwnFUBhKUpRRAq4x7rA6A1arHrFp5Tp1p21O3SfjtvB3quiOKbqWk6ZaU1Np9HwqwAecddFcB0YyBEiRX3VwF2pgpAdiPbSMuvo2qIgyob0CUoC/h4Bz1be7Qa7B0Xw9/fMKkB1LpOm925lzqosyMQM62YpMGkjMsbZz0uPopu32fxzDWSPr+kekNNyLt9InGhTpxLmq1go/pXR2uw5dfpXc5yuta7DB0EGBwnQ8Vl5HPdDooqOTD9I1jE0mRyuBpWTTI3FRnu3JUh3rIyGBJhUmHqGZvw2CKdqHCIrQeQkkEYqOeJRJVdBjhv5KGJifqT3BFRwX/YFJIChAQpebNQKXe/0kPivWokHWwXlDB7S7mBZzhaAPidZvnuIhalE2qmTypDwHy22FyqV58T8MGGMchcASDi/QXI6kcdpJzPXSeU9o+NC68QDlOIrMVxKFeE7w7PvVmAaxEo0YwmuAzzKy9QpdlK0aab/xEi8V4iXj4hGepqAvHkXIQd+r3FNeiLfllkb61p6WTjr5urcmDQMR94/wYoilpG5OlybHdbhsYHvIzYoLrC7fzl630gcO6t4nM24vdB6Ymg9BVpEgKRAxSbE62Tqacxqnz9AcmgItb48NiR/He3n3ydGjPYuKk/ihZMgEwAEZvSlNxYONSbYrIGDtOY+8Nbt6KiH3l06wjZW8tcmFeVlWv+tWotnTY9IqlAfvNVTjtsobqtQnvsiDjdEVtNy/s2ci5TH+NdZluca2OVEr91Wayxh70kpM6ib4UGbfdmGgCo74gtKvKSJU0rTHakQ5L9JlaSDD5FamBRyI0qfL43Ad9qOUZ8DaffDCyuaVyuqk7cz9HwmEmvWU3VQ+5t06n/5kRDXttcw8w+3qClEEdGo1KeENcnXCB32dQe3tDTFpuAIMLqwXs6FhpawfZ5kPYvLPczGWaqftIs/RXJ/EltGc0ugw2dmTLpoQhCqrcKEBDoYVk0LDZKsnzitOGdi9mOWse7Se8798ib1UsHFUjGzISEt6upestxOeupSTOh0v4+AjXbDzRUyogHww3V+Bqg71bkcMxtB+WM+pn1XNbVTyl9NR040nhP7KEf6e9ruXAtmrBC2ah5cFEpLIot77VFZ9ilLuitSz+7T8n1yAh1IEG6xxXxninAZIzi2qGbH69O5RSpOJuJTv17zTLJQIIc781JwQ2TTwTGnx5wZLbffhCasowJKd2EVcyMJyhz6ru0PvXWJ4hUdkARJs3Xu8dus9a86N8Xk6aAPzBDqzYb1vyFIfBxP0oO8xFHgd30Cgmz8UrSE3qeWRrF8ftrI6xQnFjHBGWD/JWSvd6YMcQED0aVuQkuNW9ST/DzQThPzRfPUoiL10yAmV7Ytu4fR3x2sF0Yfi87YhHFuCMpV/DsqxmUizyiJuD938eRcH8hzR/VO53Qo3UIsqOLcyXtTv6THjSlTopQ+JOLOnHm1w8dzYbLN44OG44rRsbihMUQp+wUZ6bsI8rrOnm9WErzkbQFbrfAINdoCiNa6cimYIjvvnMTaFWNymqY1vZxGztQiMiHiHYwTfwHTXrb9j0uPM=|09J28iXv9oWzYtzK2LBT6Yht4IT4MijEkk0fwFdrVQ4=".parse().unwrap();
        client
            .internal
            .initialize_user_crypto_master_key(
                master_key,
                user_key,
                UserKeyState {
                    private_key,
                    signing_key: None,
                    security_state: None,
                },
            )
            .unwrap();

        let public_key = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsy7RFHcX3C8Q4/OMmhhbFReYWfB45W9PDTEA8tUZwZmtOiN2RErIS2M1c+K/4HoDJ/TjpbX1f2MZcr4nWvKFuqnZXyewFc+jmvKVewYi+NAu2++vqKq2kKcmMNhwoQDQdQIVy/Uqlp4Cpi2cIwO6ogq5nHNJGR3jm+CpyrafYlbz1bPvL3hbyoGDuG2tgADhyhXUdFuef2oF3wMvn1lAJAvJnPYpMiXUFmj1ejmbwtlxZDrHgUJvUcp7nYdwUKaFoi+sOttHn3u7eZPtNvxMjhSS/X/1xBIzP/mKNLdywH5LoRxniokUk+fV3PYUxJsiU3lV0Trc/tH46jqd8ZGjmwIDAQAB";

        let encrypted = enroll_admin_password_reset(&client, public_key.to_owned()).unwrap();

        let private_key = "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzLtEUdxfcLxDj84yaGFsVF5hZ8Hjlb08NMQDy1RnBma06I3ZESshLYzVz4r/gegMn9OOltfV/Yxlyvida8oW6qdlfJ7AVz6Oa8pV7BiL40C7b76+oqraQpyYw2HChANB1AhXL9SqWngKmLZwjA7qiCrmcc0kZHeOb4KnKtp9iVvPVs+8veFvKgYO4ba2AAOHKFdR0W55/agXfAy+fWUAkC8mc9ikyJdQWaPV6OZvC2XFkOseBQm9Rynudh3BQpoWiL6w620efe7t5k+02/EyOFJL9f/XEEjM/+Yo0t3LAfkuhHGeKiRST59Xc9hTEmyJTeVXROtz+0fjqOp3xkaObAgMBAAECggEACs4xhnO0HaZhh1/iH7zORMIRXKeyxP2LQiTR8xwN5JJ9wRWmGAR9VasS7EZFTDidIGVME2u/h4s5EqXnhxfO+0gGksVvgNXJ/qw87E8K2216g6ZNo6vSGA7H1GH2voWwejJ4/k/cJug6dz2S402rRAKh2Wong1arYHSkVlQp3diiMa5FHAOSE+Cy09O2ZsaF9IXQYUtlW6AVXFrBEPYH2kvkaPXchh8VETMijo6tbvoKLnUHe+wTaDMls7hy8exjtVyI59r3DNzjy1lNGaGb5QSnFMXR+eHhPZc844Wv02MxC15zKABADrl58gpJyjTl6XpDdHCYGsmGpVGH3X9TQQKBgQDz/9beFjzq59ve6rGwn+EtnQfSsyYT+jr7GN8lNEXb3YOFXBgPhfFIcHRh2R00Vm9w2ApfAx2cd8xm2I6HuvQ1Os7g26LWazvuWY0Qzb+KaCLQTEGH1RnTq6CCG+BTRq/a3J8M4t38GV5TWlzv8wr9U4dl6FR4efjb65HXs1GQ4QKBgQC7/uHfrOTEHrLeIeqEuSl0vWNqEotFKdKLV6xpOvNuxDGbgW4/r/zaxDqt0YBOXmRbQYSEhmO3oy9J6XfE1SUln0gbavZeW0HESCAmUIC88bDnspUwS9RxauqT5aF8ODKN/bNCWCnBM1xyonPOs1oT1nyparJVdQoG//Y7vkB3+wKBgBqLqPq8fKAp3XfhHLfUjREDVoiLyQa/YI9U42IOz9LdxKNLo6p8rgVthpvmnRDGnpUuS+KOWjhdqDVANjF6G3t3DG7WNl8Rh5Gk2H4NhFswfSkgQrjebFLlBy9gjQVCWXt8KSmjvPbiY6q52Aaa8IUjA0YJAregvXxfopxO+/7BAoGARicvEtDp7WWnSc1OPoj6N14VIxgYcI7SyrzE0d/1x3ffKzB5e7qomNpxKzvqrVP8DzG7ydh8jaKPmv1MfF8tpYRy3AhmN3/GYwCnPqT75YYrhcrWcVdax5gmQVqHkFtIQkRSCIftzPLlpMGKha/YBV8c1fvC4LD0NPh/Ynv0gtECgYEAyOZg95/kte0jpgUEgwuMrzkhY/AaUJULFuR5MkyvReEbtSBQwV5tx60+T95PHNiFooWWVXiLMsAgyI2IbkxVR1Pzdri3gWK5CTfqb7kLuaj/B7SGvBa2Sxo478KS5K8tBBBWkITqo+wLC0mn3uZi1dyMWO1zopTA+KtEGF2dtGQ=";
        let private_key = STANDARD.decode(private_key).unwrap();
        let private_key = Pkcs8PrivateKeyBytes::from(private_key);
        let private_key = AsymmetricCryptoKey::from_der(&private_key).unwrap();
        let decrypted: SymmetricCryptoKey =
            encrypted.decapsulate_key_unsigned(&private_key).unwrap();

        let key_store = client.internal.get_key_store();
        let ctx = key_store.context();
        #[allow(deprecated)]
        let expected = ctx
            .dangerous_get_symmetric_key(SymmetricKeyId::User)
            .unwrap();

        assert_eq!(decrypted, *expected);
    }

    #[test]
    fn test_derive_key_connector() {
        let request = DeriveKeyConnectorRequest {
            password: "asdfasdfasdf".to_string(),
            email: "test@bitwarden.com".to_string(),
            kdf: Kdf::PBKDF2 {
                iterations: NonZeroU32::new(600_000).unwrap(),
            },
            user_key_encrypted: "2.Q/2PhzcC7GdeiMHhWguYAQ==|GpqzVdr0go0ug5cZh1n+uixeBC3oC90CIe0hd/HWA/pTRDZ8ane4fmsEIcuc8eMKUt55Y2q/fbNzsYu41YTZzzsJUSeqVjT8/iTQtgnNdpo=|dwI+uyvZ1h/iZ03VQ+/wrGEFYVewBUUl/syYgjsNMbE=".parse().unwrap(),
        };

        let result = derive_key_connector(request).unwrap();

        assert_eq!(result, "ySXq1RVLKEaV1eoQE/ui9aFKIvXTl9PAXwp1MljfF50=");
    }

    fn setup_asymmetric_keys_test() -> (UserKey, RsaKeyPair) {
        let master_key = MasterKey::derive(
            "asdfasdfasdf",
            "test@bitwarden.com",
            &Kdf::PBKDF2 {
                iterations: NonZeroU32::new(600_000).unwrap(),
            },
        )
        .unwrap();
        let user_key = (master_key.make_user_key().unwrap()).0;
        let key_pair = user_key.make_key_pair().unwrap();

        (user_key, key_pair)
    }

    #[test]
    fn test_make_key_pair() {
        let (user_key, _) = setup_asymmetric_keys_test();

        let response = make_key_pair(user_key.0.to_base64()).unwrap();

        assert!(!response.user_public_key.is_empty());
        let encrypted_private_key = response.user_key_encrypted_private_key;
        let private_key: Vec<u8> = encrypted_private_key.decrypt_with_key(&user_key.0).unwrap();
        assert!(!private_key.is_empty());
    }

    #[test]
    fn test_verify_asymmetric_keys_success() {
        let (user_key, key_pair) = setup_asymmetric_keys_test();

        let request = VerifyAsymmetricKeysRequest {
            user_key: user_key.0.to_base64(),
            user_public_key: key_pair.public,
            user_key_encrypted_private_key: key_pair.private,
        };
        let response = verify_asymmetric_keys(request).unwrap();

        assert!(response.private_key_decryptable);
        assert!(response.valid_private_key);
    }

    #[test]
    fn test_verify_asymmetric_keys_decrypt_failed() {
        let (user_key, key_pair) = setup_asymmetric_keys_test();
        let undecryptable_private_key = "2.cqD39M4erPZ3tWaz2Fng9w==|+Bsp/xvM30oo+HThKN12qirK0A63EjMadcwethCX7kEgfL5nEXgAFsSgRBMpByc1djgpGDMXzUTLOE+FejXRsrEHH/ICZ7jPMgSR+lV64Mlvw3fgvDPQdJ6w3MCmjPueGQtrlPj1K78BkRomN3vQwwRBFUIJhLAnLshTOIFrSghoyG78na7McqVMMD0gmC0zmRaSs2YWu/46ES+2Rp8V5OC4qdeeoJM9MQfaOtmaqv7NRVDeDM3DwoyTJAOcon8eovMKE4jbFPUboiXjNQBkBgjvLhco3lVJnFcQuYgmjqrwuUQRsfAtZjxFXg/RQSH2D+SI5uRaTNQwkL4iJqIw7BIKtI0gxDz6eCVdq/+DLhpImgCV/aaIhF/jkpGqLCceFsYMbuqdULMM1VYKgV+IAuyC65R+wxOaKS+1IevvPnNp7tgKAvT5+shFg8piusj+rQ49daX2SmV2OImwdWMmmX93bcVV0xJ/WYB1yrqmyRUcTwyvX3RQF25P5okIIzFasRp8jXFZe8C6f93yzkn1TPQbp95zF4OsWjfPFVH4hzca07ACt2HjbAB75JakWbFA5MbCF8aOIwIfeLVhVlquQXCldOHCsl22U/f3HTGLB9OS8F83CDAy7qZqpKha9Im8RUhHoyf+lXrky0gyd6un7Ky8NSkVOGd8CEG7bvZfutxv/qtAjEM9/lV78fh8TQIy9GNgioMzplpuzPIJOgMaY/ZFZj6a8H9OMPneN5Je0H/DwHEglSyWy7CMgwcbQgXYGXc8rXTTxL71GUAFHzDr4bAJvf40YnjndoL9tf+oBw8vVNUccoD4cjyOT5w8h7M3Liaxk9/0O8JR98PKxxpv1Xw6XjFCSEHeG2y9FgDUASFR4ZwG1qQBiiLMnJ7e9kvxsdnmasBux9H0tOdhDhAM16Afk3NPPKA8eztJVHJBAfQiaNiUA4LIJ48d8EpUAe2Tvz0WW/gQThplUINDTpvPf+FojLwc5lFwNIPb4CVN1Ui8jOJI5nsOw4BSWJvLzJLxawHxX/sBuK96iXza+4aMH+FqYKt/twpTJtiVXo26sPtHe6xXtp7uO4b+bL9yYUcaAci69L0W8aNdu8iF0lVX6kFn2lOL8dBLRleGvixX9gYEVEsiI7BQBjxEBHW/YMr5F4M4smqCpleZIAxkse1r2fQ33BSOJVQKInt4zzgdKwrxDzuVR7RyiIUuNXHsprKtRHNJrSc4x5kWFUeivahed2hON+Ir/ZvrxYN6nJJPeYYH4uEm1Nn4osUzzfWILlqpmDPK1yYy365T38W8wT0cbdcJrI87ycS37HeB8bzpFJZSY/Dzv48Yy19mDZJHLJLCRqyxNeIlBPsVC8fvxQhzr+ZyS3Wi8Dsa2Sgjt/wd0xPULLCJlb37s+1aWgYYylr9QR1uhXheYfkXFED+saGWwY1jlYL5e2Oo9n3sviBYwJxIZ+RTKFgwlXV5S+Jx/MbDpgnVHP1KaoU6vvzdWYwMChdHV/6PhZVbeT2txq7Qt+zQN59IGrOWf6vlMkHxfUzMTD58CE+xAaz/D05ljHMesLj9hb3MSrymw0PcwoFGWUMIzIQE73pUVYNE7fVHa8HqUOdoxZ5dRZqXRVox1xd9siIPE3e6CuVQIMabTp1YLno=|Y38qtTuCwNLDqFnzJ3Cgbjm1SE15OnhDm9iAMABaQBA=".parse().unwrap();

        let request = VerifyAsymmetricKeysRequest {
            user_key: user_key.0.to_base64(),
            user_public_key: key_pair.public,
            user_key_encrypted_private_key: undecryptable_private_key,
        };
        let response = verify_asymmetric_keys(request).unwrap();

        assert!(!response.private_key_decryptable);
        assert!(!response.valid_private_key);
    }

    #[test]
    fn test_verify_asymmetric_keys_parse_failed() {
        let (user_key, key_pair) = setup_asymmetric_keys_test();

        let invalid_private_key = "bad_key".to_string().encrypt_with_key(&user_key.0).unwrap();

        let request = VerifyAsymmetricKeysRequest {
            user_key: user_key.0.to_base64(),
            user_public_key: key_pair.public,
            user_key_encrypted_private_key: invalid_private_key,
        };
        let response = verify_asymmetric_keys(request).unwrap();

        assert!(response.private_key_decryptable);
        assert!(!response.valid_private_key);
    }

    #[test]
    fn test_verify_asymmetric_keys_key_mismatch() {
        let (user_key, key_pair) = setup_asymmetric_keys_test();
        let new_key_pair = user_key.make_key_pair().unwrap();

        let request = VerifyAsymmetricKeysRequest {
            user_key: user_key.0.to_base64(),
            user_public_key: key_pair.public,
            user_key_encrypted_private_key: new_key_pair.private,
        };
        let response = verify_asymmetric_keys(request).unwrap();

        assert!(response.private_key_decryptable);
        assert!(!response.valid_private_key);
    }

    #[tokio::test]
    async fn test_make_v2_keys_for_v1_user() {
        let client = Client::new(None);

        let priv_key: EncString = "2.kmLY8NJVuiKBFJtNd/ZFpA==|qOodlRXER+9ogCe3yOibRHmUcSNvjSKhdDuztLlucs10jLiNoVVVAc+9KfNErLSpx5wmUF1hBOJM8zwVPjgQTrmnNf/wuDpwiaCxNYb/0v4FygPy7ccAHK94xP1lfqq7U9+tv+/yiZSwgcT+xF0wFpoxQeNdNRFzPTuD9o4134n8bzacD9DV/WjcrXfRjbBCzzuUGj1e78+A7BWN7/5IWLz87KWk8G7O/W4+8PtEzlwkru6Wd1xO19GYU18oArCWCNoegSmcGn7w7NDEXlwD403oY8Oa7ylnbqGE28PVJx+HLPNIdSC6YKXeIOMnVs7Mctd/wXC93zGxAWD6ooTCzHSPVV50zKJmWIG2cVVUS7j35H3rGDtUHLI+ASXMEux9REZB8CdVOZMzp2wYeiOpggebJy6MKOZqPT1R3X0fqF2dHtRFPXrNsVr1Qt6bS9qTyO4ag1/BCvXF3P1uJEsI812BFAne3cYHy5bIOxuozPfipJrTb5WH35bxhElqwT3y/o/6JWOGg3HLDun31YmiZ2HScAsUAcEkA4hhoTNnqy4O2s3yVbCcR7jF7NLsbQc0MDTbnjxTdI4VnqUIn8s2c9hIJy/j80pmO9Bjxp+LQ9a2hUkfHgFhgHxZUVaeGVth8zG2kkgGdrp5VHhxMVFfvB26Ka6q6qE/UcS2lONSv+4T8niVRJz57qwctj8MNOkA3PTEfe/DP/LKMefke31YfT0xogHsLhDkx+mS8FCc01HReTjKLktk/Jh9mXwC5oKwueWWwlxI935ecn+3I2kAuOfMsgPLkoEBlwgiREC1pM7VVX1x8WmzIQVQTHd4iwnX96QewYckGRfNYWz/zwvWnjWlfcg8kRSe+68EHOGeRtC5r27fWLqRc0HNcjwpgHkI/b6czerCe8+07TWql4keJxJxhBYj3iOH7r9ZS8ck51XnOb8tGL1isimAJXodYGzakwktqHAD7MZhS+P02O+6jrg7d+yPC2ZCuS/3TOplYOCHQIhnZtR87PXTUwr83zfOwAwCyv6KP84JUQ45+DItrXLap7nOVZKQ5QxYIlbThAO6eima6Zu5XHfqGPMNWv0bLf5+vAjIa5np5DJrSwz9no/hj6CUh0iyI+SJq4RGI60lKtypMvF6MR3nHLEHOycRUQbZIyTHWl4QQLdHzuwN9lv10ouTEvNr6sFflAX2yb6w3hlCo7oBytH3rJekjb3IIOzBpeTPIejxzVlh0N9OT5MZdh4sNKYHUoWJ8mnfjdM+L4j5Q2Kgk/XiGDgEebkUxiEOQUdVpePF5uSCE+TPav/9FIRGXGiFn6NJMaU7aBsDTFBLloffFLYDpd8/bTwoSvifkj7buwLYM+h/qcnfdy5FWau1cKav+Blq/ZC0qBpo658RTC8ZtseAFDgXoQZuksM10hpP9bzD04Bx30xTGX81QbaSTNwSEEVrOtIhbDrj9OI43KH4O6zLzK+t30QxAv5zjk10RZ4+5SAdYndIlld9Y62opCfPDzRy3ubdve4ZEchpIKWTQvIxq3T5ogOhGaWBVYnkMtM2GVqvWV//46gET5SH/MdcwhACUcZ9kCpMnWH9CyyUwYvTT3UlNyV+DlS27LMPvaw7tx7qa+GfNCoCBd8S4esZpQYK/WReiS8=|pc7qpD42wxyXemdNPuwxbh8iIaryrBPu8f/DGwYdHTw=".parse().unwrap();
        let encrypted_userkey: EncString =  "2.u2HDQ/nH2J7f5tYHctZx6Q==|NnUKODz8TPycWJA5svexe1wJIz2VexvLbZh2RDfhj5VI3wP8ZkR0Vicvdv7oJRyLI1GyaZDBCf9CTBunRTYUk39DbZl42Rb+Xmzds02EQhc=|rwuo5wgqvTJf3rgwOUfabUyzqhguMYb3sGBjOYqjevc=".parse().unwrap();

        initialize_user_crypto(
            &client,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: priv_key,
                signing_key: None,
                security_state: None,
                method: InitUserCryptoMethod::Password {
                    password: "asdfasdfasdf".into(),
                    user_key: encrypted_userkey.clone(),
                },
            },
        )
        .await
        .unwrap();

        let master_key = MasterKey::derive(
            "asdfasdfasdf",
            "test@bitwarden.com",
            &Kdf::PBKDF2 {
                iterations: NonZeroU32::new(100_000).unwrap(),
            },
        )
        .unwrap();
        let enrollment_response = make_v2_keys_for_v1_user(&client).unwrap();
        let encrypted_userkey_v2 = master_key
            .encrypt_user_key(
                &SymmetricCryptoKey::try_from(enrollment_response.clone().user_key).unwrap(),
            )
            .unwrap();

        let client2 = Client::new(None);
        initialize_user_crypto(
            &client2,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: enrollment_response.private_key,
                signing_key: Some(enrollment_response.signing_key),
                security_state: Some(enrollment_response.security_state),
                method: InitUserCryptoMethod::Password {
                    password: "asdfasdfasdf".into(),
                    user_key: encrypted_userkey_v2,
                },
            },
        )
        .await
        .unwrap();
    }

    #[tokio::test]
    async fn test_make_v2_keys_for_v1_user_with_v2_user_fails() {
        let client = Client::new(None);
        #[allow(deprecated)]
        client
            .internal
            .get_key_store()
            .context_mut()
            .set_symmetric_key(
                SymmetricKeyId::User,
                SymmetricCryptoKey::make_aes256_cbc_hmac_key(),
            )
            .unwrap();
        initialize_user_crypto(
            &client,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: TEST_VECTOR_PRIVATE_KEY_V2.parse().unwrap(),
                signing_key: Some(TEST_VECTOR_SIGNING_KEY_V2.parse().unwrap()),
                security_state: Some(TEST_VECTOR_SECURITY_STATE_V2.parse().unwrap()),
                method: InitUserCryptoMethod::DecryptedKey {
                    decrypted_user_key: TEST_VECTOR_USER_KEY_V2_B64.to_string(),
                },
            },
        )
        .await
        .unwrap();

        let result = make_v2_keys_for_v1_user(&client);
        assert!(matches!(
            result,
            Err(StatefulCryptoError::WrongAccountCryptoVersion {
                expected: _,
                got: _
            })
        ));
    }

    #[test]
    fn test_get_v2_rotated_account_keys_non_v2_user() {
        let client = Client::new(None);
        #[allow(deprecated)]
        client
            .internal
            .get_key_store()
            .context_mut()
            .set_symmetric_key(
                SymmetricKeyId::User,
                SymmetricCryptoKey::make_aes256_cbc_hmac_key(),
            )
            .unwrap();

        let result = get_v2_rotated_account_keys(&client);
        assert!(matches!(
            result,
            Err(StatefulCryptoError::WrongAccountCryptoVersion {
                expected: _,
                got: _
            })
        ));
    }

    #[tokio::test]
    async fn test_get_v2_rotated_account_keys() {
        let client = Client::new(None);
        #[allow(deprecated)]
        client
            .internal
            .get_key_store()
            .context_mut()
            .set_symmetric_key(
                SymmetricKeyId::User,
                SymmetricCryptoKey::make_aes256_cbc_hmac_key(),
            )
            .unwrap();
        initialize_user_crypto(
            &client,
            InitUserCryptoRequest {
                user_id: Some(uuid::Uuid::new_v4()),
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: TEST_VECTOR_PRIVATE_KEY_V2.parse().unwrap(),
                signing_key: Some(TEST_VECTOR_SIGNING_KEY_V2.parse().unwrap()),
                security_state: Some(TEST_VECTOR_SECURITY_STATE_V2.parse().unwrap()),
                method: InitUserCryptoMethod::DecryptedKey {
                    decrypted_user_key: TEST_VECTOR_USER_KEY_V2_B64.to_string(),
                },
            },
        )
        .await
        .unwrap();

        assert!(get_v2_rotated_account_keys(&client).is_ok());
    }
}
